#include <bits/stdc++.h>
using namespace std;

/*
 * Fenwick Tree (Binary Indexed Tree) - template
 * - 1-indexed internally. Pass indices in [1..n].
 * - T should be a numeric type (int, long long, double, etc.)
 */
template<typename T = long long>
struct Fenwick {
    int n;
    vector<T> bit; // bit[1..n]

    Fenwick(int n = 0) { init(n); }

    void init(int _n) {
        n = _n;
        bit.assign(n + 1, 0);
    }

    // Build from array (1-indexed array of size n), complexity O(n)
    // If you have 0-indexed vector arr of size n, call build_from_vector(arr) below.
    void build_from_1indexed(const vector<T> &arr) {
        // arr should have size n+1 with arr[0] unused
        for (int i = 1; i <= n; ++i) bit[i] += arr[i];
        for (int i = 1; i <= n; ++i) {
            int j = i + (i & -i);
            if (j <= n) bit[j] += bit[i];
        }
    }

    // Convenience: build from 0-indexed vector
    void build_from_vector(const vector<T> &arr0) {
        init((int)arr0.size());
        vector<T> tmp(n + 1);
        for (int i = 0; i < n; ++i) tmp[i + 1] = arr0[i];
        build_from_1indexed(tmp);
    }

    // Add 'delta' at position idx (1-indexed)
    void add(int idx, T delta) {
        for (; idx <= n; idx += idx & -idx) bit[idx] += delta;
    }

    // Prefix sum [1..idx] (1-indexed)
    T sum(int idx) const {
        T res = 0;
        for (; idx > 0; idx -= idx & -idx) res += bit[idx];
        return res;
    }

    // Range sum [l..r] (1-indexed)
    T range_sum(int l, int r) const {
        if (r < l) return 0;
        return sum(r) - sum(l - 1);
    }

    // Find smallest index idx such that prefix sum >= target.
    // If no such index, returns n+1.
    // Works only if all increments are non-negative (or the prefix is non-decreasing).
    int lower_bound_prefix(T target) const {
        if (target <= 0) return 1;
        int idx = 0;
        int bitMask = 1;
        while (bitMask << 1 <= n) bitMask <<= 1;
        for (int k = bitMask; k > 0; k >>= 1) {
            int next = idx + k;
            if (next <= n && bit[next] < target) {
                idx = next;
                target -= bit[next];
            }
        }
        return idx + 1; // may be n+1 if target too large
    }
};

/*
 * RangeFenwick supports:
 *  - range_add(l, r, val): add val to every element in [l..r]
 *  - prefix_sum(idx): sum of [1..idx]
 *  - range_sum(l, r): sum of [l..r]
 *
 * Implemented using two Fenwick trees (classic trick).
 * 1-indexed operations.
 */
template<typename T = long long>
struct RangeFenwick {
    int n;
    Fenwick<T> B1, B2;

    RangeFenwick(int n = 0) { init(n); }

    void init(int _n) {
        n = _n;
        B1.init(n);
        B2.init(n);
    }

    // add val to [l..r]
    void range_add(int l, int r, T val) {
        // update BIT1 and BIT2 with the usual formula
        // internal helper
        auto _add = [&](Fenwick<T> &bit, int idx, T v) {
            bit.add(idx, v);
        };

        _add(B1, l, val);
        _add(B1, r + 1, -val);
        _add(B2, l, val * (l - 1));
        _add(B2, r + 1, -val * r);
    }

    // prefix sum [1..idx]
    T prefix_sum(int idx) const {
        auto sumBit = [&](const Fenwick<T> &bit, int i) {
            return bit.sum(i);
        };
        return sumBit(B1, idx) * idx - sumBit(B2, idx);
    }

    // range sum [l..r]
    T range_sum(int l, int r) const {
        if (r < l) return 0;
        return prefix_sum(r) - prefix_sum(l - 1);
    }
};

/* ------------------ Example usage ------------------
int main() {
    // Simple Fenwick (point update, range query)
    Fenwick<long long> fw(8);
    vector<long long> arr = {1,2,3,4,5,6,7,8}; // 0-indexed example
    fw.build_from_vector(arr); // build from arr

    // add 5 to position 3 (1-indexed)
    fw.add(3, 5);

    // prefix sum up to index 5
    cout << "sum(1..5) = " << fw.sum(5) << "\n";

    // range sum
    cout << "sum(2..6) = " << fw.range_sum(2,6) << "\n";

    // find first index with prefix >= 15
    int idx = fw.lower_bound_prefix(15);
    cout << "lower_bound_prefix(15) = " << idx << "\n";

    // RangeFenwick (range add, range sum)
    RangeFenwick<long long> rf(8);
    rf.range_add(2, 5, 10); // add 10 to indices 2..5
    cout << "range_sum(1..8) = " << rf.range_sum(1,8) << "\n";
    cout << "range_sum(3..4) = " << rf.range_sum(3,4) << "\n";

    return 0;
}
----------------------------------------------------- */

